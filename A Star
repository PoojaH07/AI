function A_STAR_MISPLACED(start, goal):
    OPEN ← priority queue
    CLOSED ← empty set
    
    g(start) = 0
    h(start) = misplaced_tiles(start, goal)
    f(start) = g(start) + h(start)
    insert start into OPEN with priority f(start)

    while OPEN not empty:
        current ← remove node with smallest f from OPEN

        if current == goal:
            return reconstruct_path(current)

        add current to CLOSED

        for each neighbor in get_neighbors(current):
            if neighbor in CLOSED:
                continue

            g(neighbor) = g(current) + 1
            h(neighbor) = misplaced_tiles(neighbor, goal)
            f(neighbor) = g(neighbor) + h(neighbor)

            if neighbor not in OPEN:
                insert neighbor into OPEN with priority f(neighbor)

    return "No solution"


function misplaced_tiles(state, goal):
    count = 0
    for i from 0 to 8:
        if state[i] != 0 and state[i] != goal[i]:
            count += 1
    return count

function manhattan_distance(state , goal):
  distance =0
  for i from 0 t0 8:
  if state[i] != 0:
    (x1,y1) = divmod(i,3)
    goal_index = position of state[i] in goal 
    (x2,y2) = divmod(goal_index,3)
    distance += abs(x1-x2)+abs(y1-y2)
  return distance
